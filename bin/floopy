#! /usr/bin/env python

import loopy as lp
import numpy as np


def main():
    from optparse import OptionParser

    description = "Stand-alone loopy frontend"

    parser = OptionParser(description=description,
            usage="%prog [options] INFILE OUTFILE")

    parser.add_option("--lang", default="loopy")
    parser.add_option("--target")
    parser.add_option("--name")
    parser.add_option("--transform")
    options, args = parser.parse_args()

    if len(args) != 2:
        raise ValueError("need exactly two arguments")

    infile, outfile = args

    # {{{ set up target

    if options.target is None:
        raise ValueError("must specify target")

    import re
    CL_TARGET_RE = re.compile(r"^cl:([0-9]+),([0-9]+)$")

    cl_target_re_match = CL_TARGET_RE.match(options.target)
    if cl_target_re_match is not None:
        platform_ordinal = int(cl_target_re_match.group(1))
        device_ordinal = int(cl_target_re_match.group(2))

        import pyopencl as cl
        plat = cl.get_platforms()[platform_ordinal]
        target = plat.get_devices()[device_ordinal]
    else:
        raise ValueError("target '%s' not understood"
                % options.target)

    # }}}

    if options.lang == "loopy":
        data_dic = {}
        data_dic["lp"] = lp
        data_dic["np"] = np
        data_dic["lp_target"] = target

        with open(infile, "r") as infile_fd:
            exec(compile(infile_fd.read(), infile, "exec"), data_dic)

        if options.transform:
            with open(options.transform, "r") as xform_fd:
                exec(compile(xform_fd.read(),
                    options.transform, "exec"), data_dic)

        try:
            kernel = data_dic["lp_knl"]
        except KeyError:
            raise RuntimeError("loopy-lang requires 'lp_knl' "
                    "to be defined on exit")

        if options.name is not None:
            kernel = kernel.copy(name=options.name)

        kernels = [kernel]

    elif options.lang == "floopy":
        with open(infile, "r") as infile_fd:
            floopy_src = infile_fd.read()

        from floopy.fortran import f2loopy
        kernels = f2loopy(target, floopy_src)

        # {{{ apply transforms from command line

        if options.transform:
            xform_dict = {}
            xform_dict["lp"] = lp
            xform_dict["np"] = np

            for kernel in kernels:
                xform_dict[kernel.name] = kernel

            with open(options.transform, "r") as xform_fd:
                exec(compile(xform_fd.read(),
                    options.transform, "exec"), xform_dict)

            new_kernels = []
            for kernel in kernels:
                new_kernels.append(xform_dict[kernel.name])

            kernels = new_kernels
            del new_kernels

        # }}}

        if options.name is not None:
            kernels = [kernel for kernel in kernels
                    if kernel.name == options.name]

        if not kernels:
            raise RuntimeError("no kernels found (name specified: %s)"
                    % options.name)

    else:
        raise RuntimeError("unknown language: '%s'"
                % options.lang)

    new_kernels = []
    for kernel in kernels:
        new_args = [
                lp.GlobalArg("occa_info", np.int32, shape=None)
                ] + kernel.args
        new_kernels.append(kernel.copy(args=new_args))

    kernels = new_kernels
    del new_kernels

    codes = []
    from loopy.codegen import generate_code
    for kernel in kernels:
        code, impl_arg_info = generate_code(kernel)
        codes.append(code)

    with open(outfile, "w") as outfile_fd:
        outfile_fd.write("\n\n".join(codes))


if __name__ == "__main__":
    main()
